第一章
1.性能增长率下降，cpu发展由 高性能单核 转向 多核
2.计算机系统的层次结构
  *微程序机器->传统机器语言机器->操作系统机器->汇编语言机器->高级语言机器->应用原因机器
  从左至右
  前两级 以硬件/固件 实现，称为物理机，后四级 以 软件 实现，称为虚拟机。
  由 底层 到 高层
  运行效率由 低 到 高
  越往左越接近硬件
3.解释和翻译
  解释：将 一条语句 转成低一级的等效程序，就立即去执行。执行完，再去转换下一句。  故花费时间多。
      /*参考同声传译*/
  翻译：先将 一段语句 转成低一级的等效程序，再去执行。     需要存储程序，故占用存储空间多。
      /*参考缓存*/
 4.系统结构的概念
   计算机系统结构是指传统机器程序员所看到的计算机属性，即概念性结构与功能特性。
   结合2可知，是在硬件层次上进行的
 5.透明性：
    在计算机技术上，把这种本来存在的事务或属性，但从某种角度看又好像不存在的概念称为透明性。
    /*用户在使用软件的时候，并不需要知道软件的编码，也就是说软件编码对用户来说是透明的*/
    /*高级语言程序员可能并不需要知道硬件的实现，故硬件实现对其来说是透明的*/
    参考2，某一层次的程序员，朝右对其可见，朝左对其透明
    思路：1.确定程序员的层次 2.确定所指内容的层次 3.判断其左右关系
  6.Amdahl定律
  
    当对系统中某一种部件进行改进后，所能获得的整个系统性能的提高，受限于该部件执行时间占总执行时间的百分比。
    /*期末成绩的组成 考试90%，平时10%，考试成绩提高10分和平时成绩提高10分，显然是不一样，这取决于他们的占比*/  
    
    性能递减规则：
    如果仅仅对计算任务中的一部分做性能改进，则改进的越多，所能得到的总体性能的提升越有限
    /*假设短跑运动员的成绩，取决于起跑、跑步中两部分，反复的提高起跑速度，可以增加其成绩，但当其起跑速度接近极限时，之后的大量起跑练习的收益会降低*/
    
    加速比=改进前的总执行时间/改进后的总执行时间
    表明改进后的计算机比之前快了多少倍。 验证：加速比>1
    取决于两个因素：
    1.可改进比例  Fe  可改进部分的执行时间/总执行时间   验证：Fe<1
    2.可改进部分的性能提高倍数 Se 可改进部分改进前的执行时间/可改进部分改进后的执行  验证 Se>1
    一个公式：
    *Tn=T0（1-Fe+Fe/Se）；
    Tn：改进后执行总时间
    T0：改进前执行总时间
    Fe，Se：见上
    /*注意灵活使用其变形*/
    
    CPU性能公式：
    执行一个程序所需的CPU时间
    CPU时间=程序占用的周期数*一个周期所需时间 
    /*其中一个周期所需时间即为时钟周期时间，是相对固定的，由硬件决定。故一般通过降低程序所占用的周期数来加速*/
    
    CPI：平均每条指令占用的周期数
    思路：总周期数/指令总条数
    CPI=执行程序所需的时间周期数/所执行的总条数
    
    其中时钟周期数可以表示为 指令数*平均每条指令的时钟周期数
    则 CPU时间=指令数*平均每条指令的时钟周期数*一个周期所需时间
    即 IC*CPI*时钟周期时间
    
    如果不告诉总CPI，给出下列信息，该如何计算CPU时间？
    某程序共300条指令，分为三种指令，指令a的CPI为4，占比50%，指令b的CPI为3，占比30%，指令c的CPI为2，占比20%
    则总CPI=4*50%+3*30%+2*20%
    利用55行的公式继续求解即可
  7.局部性原理
    程序90%的时间在执行10%的代码。
    分类：
    时间局部性：程序即将用到信息很有可能是目前正在使用的信息
    空间局部性：程序即将用到信息很可能与目前正在使用的信息空间上相近或相邻
    可用于预测程序即将要访问的指令和数据
  8.软硬件功能分配
    优化设计必须考虑软硬件的合理分配
    软件硬件在实现功能上是等价的
    一个系统只要具备了基本的硬件，就可以用软件的方法实现所有其他功能。
    比较：
      软件：设计容易，修改简单，减少硬件成本，但实现功能的速度较慢
      硬件：速度快，性能高，修改困难，灵活性差
  9.中间开始设计
    系统设计为什么要采用“从中间开始设计”？
     “从上往下”和“从下往上”会造成软硬件设计分离和脱节
    中间在哪里？
      软硬件的交界面，参考行4，及传统机器语言机器和操作系统虚拟机之间。
    硬件工作者往下（往左）设计，软件工作者往上（往右）设计
    软硬件并行的好处？
      缩短设计周期，便于交流协调
 9.性能测试
    spec测试组件：用于测试计算机在各个方面的处理性能
    实质：用于测试的程序
    分类
      1.处理器性能测试
      2.图形性能测试
    
 10.冯诺依曼计算机
    五部分：运算器，控制器、存储器、输入/输出设备。
    /*其中运算器和控制器合称CPU，也称主机*/
    特点
      1.以运算器为中心
      2.指令和数据同等对待
      3.存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的。
      4.指令由操作码和地址码组成
      /*地址码表明数据存放的位置，操作码表明对数据要进行的操作*/
      5.二进制。指令和数据均采用二进制
     改进：
      1.对输入输出方式的改进
      /*CPU需要不断查询外设是否已完成操作，才能进行后续操作，太忙了，什么都需要他管，现代改进输入输出改进的要点在：解放CPU，放权给其他U*/
       改进方式：
        1.1程序中断：CPU执行到输入输出的操作指令时，不需等待外设回答，就继续执行，外设完成输入输出操作时，向CPU发送中断请求。
            缺点：并没有改变 以运算器为中心 的缺陷
        1.2直接存储器访问（DMA）：外设与存储器之间建立数据通路，不通过运算器直接传送数据。需在主存和外设之间增加DMA控制器
            缺点；DMA每传送完一批数据，要中断CPU一次
        1.3I/O处理机：几乎把控制输入输出操作和传送信息的所有功能都从CPU中剥离出来。 
            有 处理机 和 通道 两种方式
       2.采用并行处理技术
       3.存储器组织结构的发展
         按地址访问的存储器虽然结构简单，价格便宜，存取速度快。但不符合数据查找中常用的按内容查找。
         改进：使用相联存储器（硬件）
       4.指令系统的发展
         现代计算机的指令仍由 操作码 和 地址码 两部分构成
         发展的两个方向
           1.复杂指令集（CISC）
           2.简单指令集（RISC）
  11.可移植性
     一个软件可以不经过修改或者少量修改就可以由一台计算机移植到另一台计算机上运行，差别只是执行时间不同。
     此时称这两台计算机软件兼容。
     常用方法：
      1.统一高级语言
      2.采用系利机
      3.模拟和仿真
        为什么要使用模拟和仿真？
          采用系列机的方法只能解决统一系列的计算机之间的软件移植。所以使用模拟和仿真来实现不同系统结构的计算之间的软件移植。
        模拟：使用虚拟机，通常用解释的方法实现，虚拟机上的每一条指令都用宿主机的一段程序进行解释执行。除了模拟虚拟机的指令系统，还要模拟其存储系统、I/O系统，操作系统。
             缺点：纯软件实现，速度慢，性能差
        仿真：用宿主机的微程序去解释目标机的指令系统，成为仿真微程序。除了仿真目标机的指令系统，还需要仿真其存储系统、I/O系统，控制台操作等。
        区别：
          解释执行所用的语言不同：仿真->微程序解释  模拟->机器语言解释  参考行4.
          仿真运行速度大于模拟，但是只能在系统结构相差不大的计算机之间使用。
          策略：混合使用。频度高的指令，运用仿真，频度低的难以仿真实现的用模拟。
           /*参考行24 Amdahl定律
  12.并行性
     两个方面：1.同时 2.并发
     提高途径：
      1.时间重叠：多个处理过程时间上相互错开，轮流重叠的使用同一套硬件设备的各个部分。
         应用：流水线技术
         /*部件功能专用化*/
      2.资源重复：重复设置硬件资源，以数量取胜
         应用：多处理机系统
      上述来那种方法经常同时运用。
      3.资源共享：软件方法，使多个任务按一定的时间顺序轮流的使用同一套设备。
         应用：多道程序、分时处理系统
         /*单处理机模拟多处理机*/
         
    
    
    
    
    
    
